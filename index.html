<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubSkate</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #87CEEB; /* Gökyüzü rengi */
            font-family: Arial, sans-serif;
            color: white;
        } 
        canvas { 
            display: block; 
        }
        /* UI Elemanları Stilleri */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        #shop-button, #score-display {
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #shop-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }
        #shop-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            text-align: center;
            display: none;
            pointer-events: auto;
            max-width: 90%;
            width: 500px;
            max-height: 90%;
            overflow-y: auto;
            z-index: 20;
        }
        #shop-display h2 {
            margin-top: 0;
            color: #FFD700;
        }
        .shop-item {
            background-color: rgba(50, 50, 50, 0.7);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1em;
        }
        .shop-item button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s;
        }
        .shop-item button:hover {
            background-color: #45a049;
        }
        #shop-message {
            color: yellow;
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="score-display" style="align-self: flex-end; margin-bottom: auto;">
            Skor: 0<br>Coin: 0
        </div>
        <button id="shop-button" style="align-self: flex-start; margin-top: auto;">Dükkan</button>
    </div>

    <div id="shop-display">
        <h2>SubSkate Dükkanı</h2>
        <div id="shop-items-container">
            </div>
        <p id="shop-message"></p>
        <button id="close-shop-button">Kapat</button>
    </div>
    
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

        // --- UI Elemanlarına Erişim ---
        const scoreDisplay = document.getElementById('score-display');
        const shopButton = document.getElementById('shop-button');
        const shopDisplay = document.getElementById('shop-display');
        const closeShopButton = document.getElementById('close-shop-button');
        const shopItemsContainer = document.getElementById('shop-items-container');
        const shopMessage = document.getElementById('shop-message');

        // --- Dükkan Verileri (Geçici) ---
        const shopItems = [
            { id: 'char1', type: 'character', name: 'Hızlı Ayşe', price: 0, owned: true, current: true, description: 'Başlangıç karakteri.' },
            { id: 'char2', type: 'character', name: 'Zıplayan Can', price: 250, owned: false, current: false, description: 'Daha yüksek zıplama.' },
            { id: 'power1', type: 'power', name: 'Mıknatıs (5x)', price: 50, description: '5 saniye boyunca coinleri çeker.' },
            { id: 'power2', type: 'power', name: 'Kalkan (1x)', price: 75, description: 'Bir engelden korur.' },
            { id: 'potion1', type: 'potion', name: 'Can İksiri', price: 200, description: 'Canını fuler.' }
        ];

        let playerCoins = 0; // Oyuncunun coinleri
        let playerCurrentCharacterId = 'char1'; // Aktif karakter

        // --- Dükkanı Doldurma Fonksiyonu ---
        function populateShop() {
            shopItemsContainer.innerHTML = ''; 
            shopItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                let buttonText = 'Satın Al';
                let buttonDisabled = false;
                let itemStatus = '';

                if (item.type === 'character') {
                    if (item.current) {
                        itemStatus = ' (Aktif)';
                        buttonText = 'Aktif';
                        buttonDisabled = true;
                    } else if (item.owned) {
                        itemStatus = ' (Seç)';
                        buttonText = 'Seç';
                    }
                }

                itemDiv.innerHTML = `
                    <span>${item.name} ${itemStatus} - ${item.price} Coin</span>
                    <button id="buy-${item.id}" ${buttonDisabled ? 'disabled' : ''}>${buttonText}</button>
                `;
                shopItemsContainer.appendChild(itemDiv);

                const buyButton = itemDiv.querySelector(`#buy-${item.id}`);
                buyButton.addEventListener('click', () => handleShopPurchase(item));
            });
            scoreDisplay.innerHTML = `Skor: ${Math.floor(score)}<br>Coin: ${playerCoins}`;
        }

        // --- Satın Alma İşlevi ---
        function handleShopPurchase(item) {
            shopMessage.textContent = ''; 
            if (item.current) { 
                shopMessage.textContent = 'Bu zaten aktif karakterin!';
                return;
            }
            if (item.owned && item.type === 'character') { 
                shopItems.find(i => i.id === playerCurrentCharacterId).current = false;
                item.current = true;
                playerCurrentCharacterId = item.id;
                shopMessage.textContent = `${item.name} aktif edildi!`;
                // TODO: Karakter modelini değiştirme mantığı buraya gelecek
                populateShop();
                return;
            }
            if (playerCoins >= item.price) {
                playerCoins -= item.price;
                if (item.type === 'character') {
                    shopItems.find(i => i.id === playerCurrentCharacterId).current = false; 
                    item.owned = true;
                    item.current = true;
                    playerCurrentCharacterId = item.id;
                    shopMessage.textContent = `${item.name} satın alındı ve aktif edildi!`;
                    // TODO: Karakter modelini değiştirme mantığı buraya gelecek
                } else {
                    // Diğer öğeler için satın alma mantığı (power-up, iksir)
                    shopMessage.textContent = `${item.name} satın alındı!`;
                }
                populateShop(); 
            } else {
                shopMessage.textContent = 'Yeterli coinin yok!';
            }
        }

        // --- Shop Butonu Olay Dinleyicisi ---
        shopButton.addEventListener('click', () => {
            populateShop(); 
            shopDisplay.style.display = 'block'; 
            isGamePaused = true; 
        });

        closeShopButton.addEventListener('click', () => {
            shopDisplay.style.display = 'none'; 
            isGamePaused = false; 
        });

        // --- Sahne Ayarları ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Işıklandırma ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); 
        directionalLight.position.set(0, 10, 5);
        scene.add(directionalLight);

        // --- Zemin Oluşturma (Yol) ---
        const groundGeometry = new THREE.PlaneGeometry(10, 2000); 
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x556B2F }); // Yeşilimsi kahverengi yol
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);

        // --- Oyuncu (İnsan Figürü ve Kıyafetler) ---
        const player = new THREE.Group(); 

        // Gövde (Üst)
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1E90FF }); 
        const playerBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.6), bodyMaterial);
        player.add(playerBody);

        // Kafa
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFADFAD }); 
        const playerHead = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), headMaterial);
        playerHead.position.y = 0.9;
        playerBody.add(playerHead); 

        // Pantolon
        const pantsMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); 
        const playerPants = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.6), pantsMaterial);
        playerPants.position.y = -0.6; 
        playerBody.add(playerPants);

        // Sol Ayak
        const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); 
        const playerLeftFoot = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.5), shoeMaterial);
        playerLeftFoot.position.set(-0.25, -1.2, 0.1); 
        player.add(playerLeftFoot);

        // Sağ Ayak
        const playerRightFoot = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.5), shoeMaterial);
        playerRightFoot.position.set(0.25, -1.2, 0.1); 
        player.add(playerRightFoot);

        // Kollar
        const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFADFAD }); 
        const playerLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), armMaterial);
        playerLeftArm.position.set(-0.5, 0.2, 0); 
        player.add(playerLeftArm);

        const playerRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), armMaterial);
        playerRightArm.position.set(0.5, 0.2, 0); 
        player.add(playerRightArm);


        player.position.set(0, 0.9, 0); 
        scene.add(player);


        // --- Oyun Değişkenleri ---
        const playerSpeed = 0.1; 
        const laneWidth = 3; 
        let currentLane = 0; 
        let isJumping = false;
        let jumpVelocity = 0;
        const jumpForce = 0.35; // Zıplama kuvveti artırıldı (daha yüksek zıplama)
        const gravity = -0.02; // Yerçekimi biraz artırıldı (daha hızlı iniş)

        let score = 0;
        let lastScoreUpdateTime = performance.now(); 
        let isGamePaused = false; 

        // --- Karakter Animasyonları İçin Değişkenler ---
        let animationTime = 0;
        const runAnimationSpeed = 0.25; // Koşu animasyonu hızı artırıldı
        const jumpAnimationHeightFactor = 0.8; 
        const jumpAnimationArmSwing = 0.6; // Zıplamada kol sallama açısı artırıldı
        const laneChangeAnimationSpeed = 0.2; // Şerit değiştirme dönüş hızı artırıldı
        let playerRotationTarget = 0; 

        // --- Engeller, Coinler ve Kırılabilir Kutular ---
        const obstacles = [];
        const coinsArray = [];
        const sceneryObjects = []; // Mahalle için dekoratif objeler
        const breakableBoxes = []; // Kırılabilir kutular

        let lastSpawnZ = 0; 
        const spawnDistanceMin = 15; // Objeler arası minimum Z mesafesi
        const spawnDistanceMax = 30; // Objeler arası maksimum Z mesafesi
        const scenerySpawnDistance = 25; // Sahne objeleri için spawn mesafesi
        let lastScenerySpawnZ = 0;

        const coinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16); 
        const coinMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); 

        // --- Mahalle Objeleri Oluşturma Fonksiyonları ---
        function createBuilding(x, z, width, height, depth, color) {
            const buildingGroup = new THREE.Group();
            const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = height / 2;
            buildingGroup.add(bodyMesh);

            // Çatı (isteğe bağlı)
            const roofHeight = width * 0.2;
            const roofGeometry = new THREE.ConeGeometry(width / 1.5, roofHeight, 4); // Piramit çatı
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
            roofMesh.position.y = height + roofHeight / 2;
            buildingGroup.add(roofMesh);

            // Pencereler (basit)
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xADD8E6 }); // Açık mavi pencere
            const windowGeometry = new THREE.BoxGeometry(width * 0.2, height * 0.15, 0.1);
            const numWindowsX = Math.floor(width / (width * 0.3));
            const numWindowsY = Math.floor(height / (height * 0.2));

            for (let i = 0; i < numWindowsX; i++) {
                for (let j = 0; j < numWindowsY; j++) {
                    if (Math.random() > 0.3) { // Her pencere olmasın
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            (i - numWindowsX / 2 + 0.5) * (width * 0.25),
                            (j - numWindowsY / 2 + 0.5) * (height * 0.2) + height / 2,
                            depth / 2 + 0.05 // Binanın yüzeyinde
                        );
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);
            sceneryObjects.push(buildingGroup);
        }

        function createFence(x, z, length, height) {
            const fenceGroup = new THREE.Group();
            const postGeometry = new THREE.BoxGeometry(0.2, height, 0.2);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const crossbarGeometry = new THREE.BoxGeometry(length, 0.2, 0.2);

            for (let i = -length / 2; i <= length / 2; i += length / 4) { // Direkler
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(i, height / 2, 0);
                fenceGroup.add(post);
            }
            const crossbar1 = new THREE.Mesh(crossbarGeometry, postMaterial); // Üst çıta
            crossbar1.position.set(0, height * 0.75, 0);
            fenceGroup.add(crossbar1);

            const crossbar2 = new THREE.Mesh(crossbarGeometry, postMaterial); // Alt çıta
            crossbar2.position.set(0, height * 0.25, 0);
            fenceGroup.add(crossbar2);

            fenceGroup.position.set(x, 0, z);
            scene.add(fenceGroup);
            sceneryObjects.push(fenceGroup);
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1.5;
            treeGroup.add(trunk);

            const leavesGeometry = new THREE.SphereGeometry(1.5, 16, 16); // Daha detaylı yapraklar
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 3.5;
            treeGroup.add(leaves);
            
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            sceneryObjects.push(treeGroup);
        }

        function createRoadSign(x, z) {
            const signGroup = new THREE.Group();
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1.5;
            signGroup.add(pole);

            const signGeometry = new THREE.PlaneGeometry(1.5, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide }); // Beyaz işaret
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 2.5, -0.05);
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            scene.add(signGroup);
            sceneryObjects.push(signGroup);
        }

        // --- Engel ve Coin Oluşturma Fonksiyonları ---
        function createObstacle(lane, zPosition) {
            let obstacleMesh;
            const type = Math.random();
            if (type < 0.4) { // Kutular (kırılabilir olacak)
                const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
                const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Kahverengi kutu
                obstacleMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                obstacleMesh.position.set(lane * laneWidth, 0.5, zPosition);
                obstacleMesh.isBreakable = true; // Yeni özellik
                breakableBoxes.push(obstacleMesh);
            } else if (type < 0.7) { // Duvar (üzerinden zıplanabilir)
                const wallGeometry = new THREE.BoxGeometry(2, 1.2, 0.5); // Zıplanabilir yükseklik
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); 
                obstacleMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                obstacleMesh.position.set(lane * laneWidth, 0.6, zPosition);
                obstacleMesh.isJumpable = true; // Yeni özellik
            } else { // Yüksek Engel (çarpışma)
                const tallObstacleGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.8);
                const tallObstacleMaterial = new THREE.MeshLambertMaterial({ color: 0xA0522D }); // Kırmızımsı kahverengi
                obstacleMesh = new THREE.Mesh(tallObstacleGeometry, tallObstacleMaterial);
                obstacleMesh.position.set(lane * laneWidth, 1.25, zPosition);
                obstacleMesh.isJumpable = false;
            }
            scene.add(obstacleMesh);
            obstacles.push(obstacleMesh);
        }

        function createCoin(lane, zPosition) {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2; 
            coin.position.set(lane * laneWidth, 0.5, zPosition);
            scene.add(coin);
            coinsArray.push(coin);
        }

        // --- Çarpışma Tespiti ---
        function checkCollision(obj1, obj2) {
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);
            return box1.intersectsBox(box2);
        }

        // --- Klavye Kontrolleri ---
        const keys = {};
        document.addEventListener('keydown', (event) => {
            if (isGamePaused) return; 
            keys[event.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });

        // --- Dokunmatik Kontroller (Telefon İçin) ---
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            if (isGamePaused) return; 
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }, false);

        document.addEventListener('touchend', (event) => {
            if (isGamePaused) return; 
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // Dikey kaydırma (zıplama)
            if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 50) { 
                if (dy < 0 && !isJumping) { 
                    isJumping = true;
                    jumpVelocity = jumpForce;
                }
            } 
            // Yatay kaydırma (şerit değiştirme)
            else if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) { 
                if (dx > 0) { // Sağa kaydırma
                    currentLane = Math.min(currentLane + 1, 1);
                    playerRotationTarget = -Math.PI / 10; 
                } else { // Sola kaydırma
                    currentLane = Math.max(currentLane - 1, -1);
                    playerRotationTarget = Math.PI / 10; 
                }
            }
        }, false);

        // --- Animasyon Döngüsü ---
        let lastFrameTime = performance.now(); 

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; 
            lastFrameTime = currentTime;

            if (isGamePaused) {
                renderer.render(scene, camera); 
                return; 
            }

            // Skor Güncelleme
            score += deltaTime; 
            scoreDisplay.innerHTML = `Skor: ${Math.floor(score)}<br>Coin: ${playerCoins}`;

            // Oyuncuyu sürekli ileri hareket ettir
            player.position.z -= playerSpeed;
            camera.position.z = player.position.z + 5; 

            // Oyuncunun şerit pozisyonunu güncelle ve dönüş animasyonu
            const targetX = currentLane * laneWidth;
            player.position.x += (targetX - player.position.x) * 0.1; 
            player.rotation.y += (playerRotationTarget - player.rotation.y) * laneChangeAnimationSpeed;


            // Zıplama Mantığı
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity += gravity; 
                
                // Zıplama animasyonu (daha belirgin ve doğal)
                const jumpProgress = (player.position.y - 0.9) / (jumpForce * jumpForce / (2 * Math.abs(gravity)));
                
                // Ayaklar - havada bükülme ve toplanma
                playerLeftFoot.rotation.x = Math.sin(jumpProgress * Math.PI) * Math.PI / 3; // Daha fazla bükülme
                playerRightFoot.rotation.x = Math.sin(jumpProgress * Math.PI) * Math.PI / 3;
                playerLeftFoot.position.y = -1.2 + Math.abs(Math.sin(jumpProgress * Math.PI)) * 0.7; // Daha yüksek kalkma
                playerRightFoot.position.y = -1.2 + Math.abs(Math.sin(jumpProgress * Math.PI)) * 0.7;
                playerLeftFoot.position.z = Math.sin(jumpProgress * Math.PI) * 0.2; // Hafif geri çekilme
                playerRightFoot.position.z = Math.sin(jumpProgress * Math.PI) * 0.2;

                // Kollar - zıplama hareketi (daha dinamik)
                playerLeftArm.rotation.x = Math.PI / 3 - Math.sin(jumpProgress * Math.PI) * jumpAnimationArmSwing; // Daha yukarı kalkma
                playerRightArm.rotation.x = -Math.PI / 3 + Math.sin(jumpProgress * Math.PI) * jumpAnimationArmSwing;


                if (player.position.y <= 0.9) { 
                    player.position.y = 0.9;
                    isJumping = false;
                    jumpVelocity = 0;
                    // Zıplama bitti, koşu animasyonuna geri dön
                    playerLeftFoot.rotation.x = 0; 
                    playerRightFoot.rotation.x = 0;
                    playerLeftFoot.position.y = -1.2; 
                    playerRightFoot.position.y = -1.2;
                    playerLeftFoot.position.z = 0;
                    playerRightFoot.position.z = 0;
                    playerLeftArm.rotation.x = 0; 
                    playerRightArm.rotation.x = 0;
                    playerRotationTarget = 0; 
                }
            } else {
                // Koşu Animasyonu (Yerdeyse) - Daha belirgin
                animationTime += runAnimationSpeed;
                // Ayaklar ileri-geri ve hafif yukarı-aşağı
                playerLeftFoot.position.z = Math.sin(animationTime) * 0.2;
                playerLeftFoot.position.y = -1.2 + Math.abs(Math.sin(animationTime)) * 0.2; 

                playerRightFoot.position.z = Math.sin(animationTime + Math.PI) * 0.2; 
                playerRightFoot.position.y = -1.2 + Math.abs(Math.sin(animationTime + Math.PI)) * 0.2;

                // Kollar ileri-geri (ayaklara ters orantılı)
                playerLeftArm.rotation.x = Math.sin(animationTime + Math.PI) * 0.4; 
                playerRightArm.rotation.x = Math.sin(animationTime) * 0.4;
            }

            // Klavye ile zıplama
            if (keys[' '] && !isJumping) { 
                isJumping = true;
                jumpVelocity = jumpForce;
            }

            // Klavye ile yana kayma (A/D veya Sol/Sağ Ok)
            if (keys['a'] || keys['arrowleft']) {
                currentLane = Math.max(currentLane - 1, -1);
                playerRotationTarget = Math.PI / 10; 
                keys['a'] = false; 
                keys['arrowleft'] = false;
            }
            if (keys['d'] || keys['arrowright']) {
                currentLane = Math.min(currentLane + 1, 1);
                playerRotationTarget = -Math.PI / 10; 
                keys['d'] = false; 
                keys['arrowright'] = false;
            }
            // Tuş basılı değilse rotasyonu sıfırla
            if (!keys['a'] && !keys['d'] && !keys['arrowleft'] && !keys['arrowright'] && !isJumping) {
                playerRotationTarget = 0;
            }


            // --- Engel, Coin, Kırılabilir Kutu ve Mahalle Objeleri Üretimi ---
            if (player.position.z - lastSpawnZ < -Math.random() * (spawnDistanceMax - spawnDistanceMin) - spawnDistanceMin) {
                 const randomLane = Math.floor(Math.random() * 3) - 1; 
                 const spawnChoice = Math.random();
                 const spawnZ = player.position.z - (Math.random() * 50 + 30); 

                 if (spawnChoice < 0.6) { 
                     createObstacle(randomLane, spawnZ);
                 } else { 
                     createCoin(randomLane, spawnZ);
                 }
                 lastSpawnZ = player.position.z;
            }

            // Mahalle objelerini üretme
            if (player.position.z - lastScenerySpawnZ < -scenerySpawnDistance) {
                const zPos = player.position.z - 100; 
                const side = Math.random() < 0.5 ? -1 : 1; 

                // Kaldırım
                const pavementGeometry = new THREE.BoxGeometry(laneWidth + 1, 0.1, 20); // Yolun yanına uzun kaldırım
                const pavementMaterial = new THREE.MeshLambertMaterial({ color: 0xAAAAAA }); // Gri
                const pavement = new THREE.Mesh(pavementGeometry, pavementMaterial);
                pavement.position.set(side * (laneWidth + pavementGeometry.parameters.width / 2 - 0.5), 0.05, zPos);
                scene.add(pavement);
                sceneryObjects.push(pavement);

                // Bina
                if (Math.random() < 0.7) {
                    const buildingWidth = Math.random() * 10 + 5;
                    const buildingHeight = Math.random() * 15 + 10;
                    const buildingDepth = Math.random() * 8 + 5;
                    const buildingColor = new THREE.Color(Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3); 
                    createBuilding(side * (laneWidth * 2 + buildingWidth / 2 + Math.random() * 5), zPos, buildingWidth, buildingHeight, buildingDepth, buildingColor);
                }

                // Çit, Ağaç veya Yol İşareti
                const smallObjectChoice = Math.random();
                const smallObjectX = side * (laneWidth * 1.5 + Math.random() * 3);
                const smallObjectZ = zPos + Math.random() * 10 - 5;
                if (smallObjectChoice < 0.4) {
                    createFence(smallObjectX, smallObjectZ, 5, 1);
                } else if (smallObjectChoice < 0.8) {
                    createTree(smallObjectX, smallObjectZ);
                } else {
                    createRoadSign(smallObjectX, smallObjectZ);
                }
                
                lastScenerySpawnZ = player.position.z;
            }


            // --- Objeleri Hareket Ettirme ve Silme ---
            const cleanupDistance = camera.position.z + 20; 

            // Engeller
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += playerSpeed; 

                // Çarpışma Tespiti
                if (checkCollision(player, obstacle)) {
                    if (obstacle.isBreakable) {
                        // Kutu kırıldı, rastgele coin ver
                        const earnedCoins = Math.floor(Math.random() * 5) + 1; // 1-5 arası
                        playerCoins += earnedCoins;
                        scoreDisplay.innerHTML = `Skor: ${Math.floor(score)}<br>Coin: ${playerCoins}`;
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                        // Kırılma animasyonu/efekti eklenebilir
                        console.log(`Kutu kırıldı! ${earnedCoins} coin kazandın.`);
                    } else if (obstacle.isJumpable && isJumping && player.position.y > obstacle.position.y + obstacle.geometry.parameters.height / 2 + 0.1) {
                        // Zıplanabilir engelin üzerinden atladı
                        // Hiçbir şey yapma, oyuna devam et
                        console.log("Engelin üzerinden atladın!");
                    }
                    else {
                        // Engel (yüksek olan veya zıplanamayan) ile çarpışma
                        console.log("Çarpıştın! Oyun Bitti!");
                        isGamePaused = true; 
                        shopButton.textContent = "Tekrar Oyna"; 
                        shopButton.onclick = () => { 
                            location.reload(); 
                        };
                        return; 
                    }
                }

                // Ekran dışına çıkanları sil
                if (obstacle.position.z > cleanupDistance) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }

            // Coinler
            for (let i = coinsArray.length - 1; i >= 0; i--) {
                const coin = coinsArray[i];
                coin.position.z += playerSpeed;
                coin.rotation.y += 0.05; 

                // Coin toplama tespiti
                if (checkCollision(player, coin) && coin.visible) {
                    playerCoins += 1; 
                    scoreDisplay.innerHTML = `Skor: ${Math.floor(score)}<br>Coin: ${playerCoins}`;
                    scene.remove(coin); 
                    coin.visible = false; 
                }

                // Ekran dışına çıkanları sil
                if (coin.position.z > cleanupDistance) {
                    scene.remove(coin);
                    coinsArray.splice(i, 1);
                }
            }

            // Kırılabilir kutular (collision'dan sonra silindikleri için ekstra döngüye gerek yok, ama burada tutabiliriz)
            for (let i = breakableBoxes.length - 1; i >= 0; i--) {
                const box = breakableBoxes[i];
                box.position.z += playerSpeed;
                if (box.position.z > cleanupDistance) {
                    scene.remove(box);
                    breakableBoxes.splice(i, 1);
                }
            }

            // Mahalle objeleri
            for (let i = sceneryObjects.length - 1; i >= 0; i--) {
                const obj = sceneryObjects[i];
                obj.position.z += playerSpeed;

                // Ekran dışına çıkanları sil
                if (obj.position.z > cleanupDistance) {
                    scene.remove(obj);
                    sceneryObjects.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- Pencere Boyutu Değiştiğinde Yeniden Boyutlandırma ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Dükkanı başlangıçta doldur
        populateShop();
    </script>
</body>
</html>
