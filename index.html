<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubSkate</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Gökyüzü rengi */
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas {
            display: block;
        }
        /* UI Elemanları Stilleri */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto; /* Varsayılan olarak tüm UI kapsayıcısı etkileşime açık */
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        #ui-container.disabled-for-game { /* Oyun duraklatıldığında (dükkan açıkken) */
            pointer-events: none; /* UI etkileşime kapalı */
        }
        #top-right-controls {
            align-self: flex-end;
            margin-bottom: auto;
            text-align: right;
            pointer-events: auto; /* İçindeki butonlar etkileşime açık */
        }
        #bottom-left-controls {
            align-self: flex-start;
            margin-top: auto;
            pointer-events: auto; /* İçindeki butonlar etkileşime açık */
        }

        #shop-button, #score-display, #speed-boost-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
            margin-bottom: 10px; /* Butonlar arası boşluk */
        }
        #shop-button:hover, #speed-boost-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        #shop-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            text-align: center;
            display: none; /* Varsayılan olarak gizli */
            pointer-events: auto; /* Dükkan açıkken etkileşime açık */
            max-width: 90%;
            width: 500px;
            max-height: 90%;
            overflow-y: auto;
            z-index: 20;
            flex-direction: column; /* İçeriği dikey sırala */
            gap: 15px; /* Dükkan içindeki elemanlar arası boşluk */
        }
        #shop-display.active { /* Yeni görünürlük sınıfı */
            display: flex;
        }

        #shop-display h2 {
            margin-top: 0;
            color: #FFD700;
        }
        #shop-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .shop-tab-button {
            background-color: #555;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 5px;
            transition: background-color 0.3s;
        }
        .shop-tab-button.active {
            background-color: #777;
        }
        .shop-tab-button:hover {
            background-color: #666;
        }
        .shop-section {
            display: none; /* Varsayılan olarak gizli */
            flex-direction: column; /* İçeriği dikey sırala */
            gap: 10px;
        }
        .shop-section.active {
            display: flex; /* Aktif olduğunda görünür */
        }
        .shop-item {
            background-color: rgba(50, 50, 50, 0.7);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1em;
        }
        .shop-item .color-box {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        .shop-item button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s;
        }
        .shop-item button:hover {
            background-color: #45a049;
        }
        .shop-item button:disabled {
            background-color: #777;
            cursor: not-allowed;
        }
        #shop-message {
            color: yellow;
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="top-right-controls">
            <div id="score-display">
                Skor: 0<br>Coin: 0
            </div>
            <button id="speed-boost-button" style="display:none;">Hızlı Koş (0)</button> </div>

        <div id="bottom-left-controls">
            <button id="shop-button">Dükkan</button>
        </div>
    </div>

    <div id="shop-display">
        <h2>SubSkate Dükkanı</h2>
        <div id="shop-tabs">
            <button class="shop-tab-button active" data-tab="outfits">Kıyafetler</button>
            <button class="shop-tab-button" data-tab="powers">Özel Güçler</button>
        </div>

        <div id="outfit-shop-section" class="shop-section active">
            <h3>Kıyafetler</h3>
            <div id="outfit-items-container">
                </div>
        </div>

        <div id="power-shop-section" class="shop-section">
            <h3>Özel Güçler</h3>
            <div id="power-items-container">
                </div>
        </div>

        <p id="shop-message"></p>
        <button id="close-shop-button">Kapat</button>
    </div>

    <script type="module">
        // Tüm JavaScript kodunu DOMContentLoaded olayına sarmalayarak, HTML içeriğinin tamamen yüklendiğinden emin oluyoruz.
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded: HTML içeriği yüklendi.");

            // Three.js kütüphanelerini import et
            import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
            import { FontLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/FontLoader.js';
            import { TextGeometry } from 'https://unpkg.com/three@0.165.0/examples/jsm/geometries/TextGeometry.js';

            console.log("THREE, FontLoader, TextGeometry import edildi.");

            // --- UI Elemanlarına Erişim ---
            const uiContainer = document.getElementById('ui-container');
            const scoreDisplay = document.getElementById('score-display');
            const shopButton = document.getElementById('shop-button');
            const shopDisplay = document.getElementById('shop-display');
            const closeShopButton = document.getElementById('close-shop-button');
            const outfitItemsContainer = document.getElementById('outfit-items-container');
            const powerItemsContainer = document.getElementById('power-items-container');
            const shopMessage = document.getElementById('shop-message');
            const shopTabButtons = document.querySelectorAll('.shop-tab-button');
            const shopSections = document.querySelectorAll('.shop-section');
            const speedBoostButton = document.getElementById('speed-boost-button');

            console.log("UI elementleri başarıyla alındı.");

            // --- Dükkan Verileri (Kıyafetler) ---
            const outfitItems = [
                { id: 'shirt_blue', type: 'shirt', name: 'Mavi Üst', color: 0x1E90FF, price: 0, owned: true, current: true },
                { id: 'shirt_red', type: 'shirt', name: 'Kırmızı Üst', color: 0xFF0000, price: 100, owned: false, current: false },
                { id: 'shirt_green', type: 'shirt', name: 'Yeşil Üst', color: 0x008000, price: 100, owned: false, current: false },
                { id: 'pants_green', type: 'pants', name: 'Yeşil Pantolon', color: 0x228B22, price: 0, owned: true, current: true },
                { id: 'pants_blue', type: 'pants', name: 'Mavi Pantolon', color: 0x0000FF, price: 100, owned: false, current: false },
                { id: 'pants_black', type: 'pants', name: 'Siyah Pantolon', color: 0x000000, price: 100, owned: false, current: false },
                { id: 'shoes_brown', type: 'shoes', name: 'Kahverengi Ayakkabı', color: 0x8B4513, price: 0, owned: true, current: true },
                { id: 'shoes_white', type: 'shoes', name: 'Beyaz Ayakkabı', color: 0xFFFFFF, price: 75, owned: false, current: false },
                { id: 'shoes_red', type: 'shoes', name: 'Kırmızı Ayakkabı', color: 0xDD2222, price: 75, owned: false, current: false },
            ];

            // --- Dükkan Verileri (Özel Güçler) ---
            const powerItems = [
                { id: 'speed_boost', name: 'Hızlandırma', description: '5 saniye boyunca %50 hız artışı.', price: 50, owned: 0, type: 'consumable' }
            ];

            let playerCoins = 0;
            let speedBoostCount = 0;
            let isSpeedBoostActive = false;
            let speedBoostTimer = 0;
            const SPEED_BOOST_DURATION = 5;
            const SPEED_BOOST_MULTIPLIER = 1.5;

            // --- Dükkan Tab Kontrolleri ---
            shopTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    console.log(`Tab clicked: ${button.dataset.tab}`);
                    shopTabButtons.forEach(btn => btn.classList.remove('active'));
                    shopSections.forEach(section => section.classList.remove('active'));

                    button.classList.add('active');
                    document.getElementById(`${button.dataset.tab}-shop-section`).classList.add('active');
                    shopMessage.textContent = '';
                    populateShop();
                });
            });

            // --- Dükkanı Doldurma Fonksiyonları ---
            function populateOutfitShop() {
                outfitItemsContainer.innerHTML = '';
                outfitItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item';
                    let buttonText = 'Satın Al';
                    let buttonDisabled = false;
                    let itemStatus = '';

                    if (item.current) {
                        itemStatus = ' (Aktif)';
                        buttonText = 'Aktif';
                        buttonDisabled = true;
                    } else if (item.owned) {
                        itemStatus = ' (Seç)';
                        buttonText = 'Seç';
                    }

                    itemDiv.innerHTML = `
                        <span class="color-box" style="background-color: #${item.color.toString(16).padStart(6, '0')};"></span>
                        <span>${item.name} ${itemStatus} - ${item.price} Coin</span>
                        <button id="buy-${item.id}" ${buttonDisabled ? 'disabled' : ''}>${buttonText}</button>
                    `;
                    outfitItemsContainer.appendChild(itemDiv);

                    const buyButton = itemDiv.querySelector(`#buy-${item.id}`);
                    buyButton.addEventListener('click', () => handleOutfitPurchase(item));
                });
                updateScoreAndCoinsDisplay();
            }

            function populatePowerShop() {
                powerItemsContainer.innerHTML = '';
                powerItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item';
                    let buttonText = 'Satın Al';
                    let buttonDisabled = false;

                    itemDiv.innerHTML = `
                        <span>${item.name} (${item.owned}) - ${item.price} Coin</span>
                        <button id="buy-${item.id}" ${buttonDisabled ? 'disabled' : ''}>${buttonText}</button>
                    `;
                    powerItemsContainer.appendChild(itemDiv);

                    const buyButton = itemDiv.querySelector(`#buy-${item.id}`);
                    buyButton.addEventListener('click', () => handlePowerPurchase(item));
                });
                updateScoreAndCoinsDisplay();
            }

            function populateShop() {
                const activeTabButton = document.querySelector('.shop-tab-button.active');
                if (activeTabButton) {
                    const activeTab = activeTabButton.dataset.tab;
                    console.log(`Populating shop for active tab: ${activeTab}`);
                    if (activeTab === 'outfits') {
                        populateOutfitShop();
                    } else if (activeTab === 'powers') {
                        populatePowerShop();
                    }
                } else {
                    console.warn("No active shop tab found. Defaulting to outfits.");
                    populateOutfitShop(); // Fallback
                }
            }

            // --- Satın Alma ve Giydirme İşlevi ---
            function handleOutfitPurchase(item) {
                shopMessage.textContent = '';
                if (item.current) {
                    shopMessage.textContent = 'Bu zaten aktif kıyafetin!';
                    return;
                }
                if (item.owned) {
                    outfitItems.filter(o => o.type === item.type).forEach(o => o.current = false);
                    item.current = true;
                    shopMessage.textContent = `${item.name} aktif edildi!`;
                    updatePlayerOutfit(item.type, item.color);
                    populateOutfitShop();
                    return;
                }
                if (playerCoins >= item.price) {
                    playerCoins -= item.price;
                    outfitItems.filter(o => o.type === item.type).forEach(o => o.current = false);
                    item.owned = true;
                    item.current = true;
                    shopMessage.textContent = `${item.name} satın alındı ve aktif edildi!`;
                    updatePlayerOutfit(item.type, item.color);
                    populateOutfitShop();
                } else {
                    shopMessage.textContent = 'Yeterli coinin yok!';
                }
            }

            function handlePowerPurchase(item) {
                shopMessage.textContent = '';
                if (playerCoins >= item.price) {
                    playerCoins -= item.price;
                    item.owned++;
                    if (item.id === 'speed_boost') {
                        speedBoostCount = item.owned;
                        updateSpeedBoostButton();
                    }
                    shopMessage.textContent = `${item.name} satın alındı! Elinizde ${item.owned} adet var.`;
                    populatePowerShop();
                } else {
                    shopMessage.textContent = 'Yeterli coinin yok!';
                }
            }

            // --- Karakterin Kıyafetini Güncelleme Fonksiyonu ---
            function updatePlayerOutfit(type, color) {
                console.log(`Updating player outfit: Type=${type}, Color=0x${color.toString(16).toUpperCase()}`);
                if (!playerBody || !playerPants || !playerLeftFoot || !playerRightFoot) {
                    console.error("Player body parts not initialized yet, cannot update outfit.");
                    return;
                }
                switch (type) {
                    case 'shirt':
                        playerBody.material.color.set(color);
                        break;
                    case 'pants':
                        playerPants.material.color.set(color);
                        break;
                    case 'shoes':
                        playerLeftFoot.material.color.set(color);
                        playerRightFoot.material.color.set(color);
                        break;
                }
            }

            function updateScoreAndCoinsDisplay() {
                scoreDisplay.innerHTML = `Skor: ${Math.floor(score)}<br>Coin: ${playerCoins}`;
            }

            function updateSpeedBoostButton() {
                if (speedBoostCount > 0) {
                    speedBoostButton.style.display = 'block';
                    speedBoostButton.textContent = `Hızlı Koş (${speedBoostCount})`;
                } else {
                    speedBoostButton.style.display = 'none';
                }
            }

            speedBoostButton.addEventListener('click', () => {
                if (speedBoostCount > 0 && !isSpeedBoostActive) {
                    speedBoostCount--;
                    updateSpeedBoostButton();
                    isSpeedBoostActive = true;
                    speedBoostTimer = SPEED_BOOST_DURATION;
                    playerSpeed = 0.1 * SPEED_BOOST_MULTIPLIER;
                    console.log("Hızlandırma aktif!");
                }
            });

            // --- Shop Butonu Olay Dinleyicisi ---
            shopButton.addEventListener('click', () => {
                console.log("Shop button clicked. Pausing game.");
                isGamePaused = true;
                shopDisplay.classList.add('active');
                uiContainer.classList.add('disabled-for-game');
                populateShop();
            });

            closeShopButton.addEventListener('click', () => {
                console.log("Close shop button clicked. Resuming game.");
                shopDisplay.classList.remove('active');
                isGamePaused = false;
                uiContainer.classList.remove('disabled-for-game');
            });


            // --- Sahne Ayarları ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            console.log("Three.js sahne, kamera, renderer başlatıldı.");

            // --- Işıklandırma ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // --- Zemin Oluşturma (Yol) ---
            const LANE_WIDTH = 3;
            const ROAD_TOTAL_WIDTH = LANE_WIDTH * 3 + 2;

            const roadGeometry = new THREE.PlaneGeometry(ROAD_TOTAL_WIDTH, 2000);
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01;
            scene.add(road);

            const dashedLineMaterial = new THREE.LineDashedMaterial({
                color: 0xffff00,
                linewidth: 3,
                scale: 1,
                dashSize: 1,
                gapSize: 1
            });

            const lineGeometry1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-LANE_WIDTH / 2, 0.02, -1000), new THREE.Vector3(-LANE_WIDTH / 2, 0.02, 1000)]);
            const line1 = new THREE.Line(lineGeometry1, dashedLineMaterial);
            line1.computeLineDistances();
            scene.add(line1);

            const lineGeometry2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(LANE_WIDTH / 2, 0.02, -1000), new THREE.Vector3(LANE_WIDTH / 2, 0.02, 1000)]);
            const line2 = new THREE.Line(lineGeometry2, dashedLineMaterial);
            line2.computeLineDistances();
            scene.add(line2);

            console.log("Yol ve şeritler oluşturuldu.");

            // --- Oyuncu (İnsan Figürü ve Kıyafetler) ---
            const player = new THREE.Group();

            const playerBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.6), new THREE.MeshLambertMaterial({ color: outfitItems.find(item => item.current && item.type === 'shirt').color }));
            player.add(playerBody);

            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFADFAD });
            const playerHead = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), headMaterial);
            playerHead.position.y = 0.9;
            playerBody.add(playerHead);

            const playerPants = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.6), new THREE.MeshLambertMaterial({ color: outfitItems.find(item => item.current && item.type === 'pants').color }));
            playerPants.position.y = -0.6;
            playerBody.add(playerPants);

            const playerLeftFoot = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.5), new THREE.MeshLambertMaterial({ color: outfitItems.find(item => item.current && item.type === 'shoes').color }));
            playerLeftFoot.position.set(-0.25, -1.2, 0.1);
            player.add(playerLeftFoot);

            const playerRightFoot = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.5), new THREE.MeshLambertMaterial({ color: outfitItems.find(item => item.current && item.type === 'shoes').color }));
            playerRightFoot.position.set(0.25, -1.2, 0.1);
            player.add(playerRightFoot);

            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFADFAD });
            const playerLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), armMaterial);
            playerLeftArm.position.set(-0.5, 0.2, 0);
            player.add(playerLeftArm);

            const playerRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), armMaterial);
            playerRightArm.position.set(0.5, 0.2, 0);
            player.add(playerRightArm);


            player.position.set(0, 0.9, 0);
            scene.add(player);

            console.log("Oyuncu karakteri oluşturuldu.");

            // --- Oyun Değişkenleri ---
            let playerSpeed = 0.1;
            let currentLane = 0;
            let isJumping = false;
            let jumpVelocity = 0;
            const jumpForce = 0.6;
            const gravity = -0.04;

            let score = 0;
            let lastScoreUpdateTime = performance.now();
            let isGamePaused = false;

            // --- Karakter Animasyonları İçin Değişkenler ---
            let animationTime = 0;
            const runAnimationSpeed = 0.35;
            let playerRotationTarget = 0;

            // --- Engeller, Coinler ve Kırılabilir Kutular ---
            const obstacles = [];
            const coinsArray = [];
            const sceneryObjects = [];

            let lastSpawnZ = 0;
            const spawnDistanceMin = 10;
            const spawnDistanceMax = 20;
            const scenerySpawnDistance = 15;
            let lastScenerySpawnZ = 0;
            const roadSideOffset = ROAD_TOTAL_WIDTH / 2 + 2;

            const coinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
            const coinMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });

            // FontLoader ve TextGeometry'yi yükle
            let loadedFont = null; // Font yüklenmeden null olarak başlasın
            const fontLoader = new FontLoader();
            fontLoader.load(
                'https://unpkg.com/three@0.165.0/examples/fonts/helvetiker_regular.typeface.json',
                function ( font ) {
                    loadedFont = font;
                    console.log("Font yüklendi!");
                },
                undefined, // onProgress callback
                function ( err ) {
                    console.error( 'Font yüklenirken hata oluştu:', err );
                }
            );

            // --- Mahalle Objeleri Oluşturma Fonksiyonları ---
            function createBuilding(x, z, width, height, depth, color) {
                const buildingGroup = new THREE.Group();
                const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                bodyMesh.position.y = height / 2;
                buildingGroup.add(bodyMesh);

                const roofHeight = width * 0.2;
                let roofMesh;
                if (Math.random() < 0.7) {
                    const roofGeometry = new THREE.ConeGeometry(width / 1.5, roofHeight, 4);
                    const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
                    roofMesh.position.y = height + roofHeight / 2;
                } else {
                    const roofGeometry = new THREE.BoxGeometry(width, 0.2, depth);
                    const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
                    roofMesh.position.y = height + 0.1;
                }
                buildingGroup.add(roofMesh);

                const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xADD8E6 });
                const windowGeometry = new THREE.BoxGeometry(width * 0.2, height * 0.15, 0.1);

                const facadeTypes = ['front', 'side'];
                const selectedFacade = facadeTypes[Math.floor(Math.random() * facadeTypes.length)];
                const sideMultiplier = x > 0 ? 1 : -1;

                const numWindowsX = Math.floor(width / (width * 0.3));
                const numWindowsY = Math.floor(height / (height * 0.2));

                for (let i = 0; i < numWindowsX; i++) {
                    for (let j = 0; j < numWindowsY; j++) {
                        if (Math.random() > 0.3) {
                            const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                            if (selectedFacade === 'front') {
                                windowMesh.position.set(
                                    (i - numWindowsX / 2 + 0.5) * (width * 0.25),
                                    (j - numWindowsY / 2 + 0.5) * (height * 0.2) + height / 2,
                                    depth / 2 + 0.05
                                );
                            } else {
                                windowMesh.rotation.y = Math.PI / 2;
                                windowMesh.position.set(
                                    sideMultiplier * (width / 2 + 0.05),
                                    (j - numWindowsY / 2 + 0.5) * (height * 0.2) + height / 2,
                                    (i - numWindowsX / 2 + 0.5) * (depth * 0.25)
                                );
                            }
                            buildingGroup.add(windowMesh);
                        }
                    }
                }

                buildingGroup.position.set(x, 0, z);
                scene.add(buildingGroup);
                sceneryObjects.push(buildingGroup);
            }

            function createFence(x, z, length, height) {
                const fenceGroup = new THREE.Group();
                const postGeometry = new THREE.BoxGeometry(0.2, height, 0.2);
                const postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const crossbarGeometry = new THREE.BoxGeometry(length, 0.2, 0.2);

                for (let i = -length / 2; i <= length / 2; i += length / 4) {
                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.set(i, height / 2, 0);
                    fenceGroup.add(post);
                }
                const crossbar1 = new THREE.Mesh(crossbarGeometry, postMaterial);
                crossbar1.position.set(0, height * 0.75, 0);
                fenceGroup.add(crossbar1);

                const crossbar2 = new THREE.Mesh(crossbarGeometry, postMaterial);
                crossbar2.position.set(0, height * 0.25, 0);
                fenceGroup.add(crossbar2);

                fenceGroup.position.set(x, 0, z);
                scene.add(fenceGroup);
                sceneryObjects.push(fenceGroup);
            }

            function createTree(x, z) {
                const treeGroup = new THREE.Group();
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1.5;
                treeGroup.add(trunk);

                const leavesGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 3.5;
                treeGroup.add(leaves);

                treeGroup.position.set(x, 0, z);
                scene.add(treeGroup);
                sceneryObjects.push(treeGroup);
            }

            function createRoadSign(x, z) {
                const signGroup = new THREE.Group();
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 1.5;
                signGroup.add(pole);

                const signGeometry = new THREE.PlaneGeometry(1.5, 1);
                const signMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(0, 2.5, -0.05);
                signGroup.add(sign);

                // "STOP" yazısı
                if (loadedFont) {
                    try {
                        const textGeometry = new TextGeometry( 'STOP', {
                            font: loadedFont,
                            size: 0.5,
                            height: 0.1,
                            curveSegments: 2,
                            bevelEnabled: false
                        });
                        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                        textGeometry.computeBoundingBox();
                        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                        const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
                        textMesh.position.set(-textWidth / 2, 2.5 - textHeight / 2, 0.01);
                        signGroup.add(textMesh);
                    } catch (e) {
                        console.error("Yazı objesi oluşturulurken hata:", e);
                    }
                } else {
                    console.warn("Font henüz yüklenmedi, yol tabelasına yazı eklenemedi.");
                }

                signGroup.position.set(x, 0, z);
                scene.add(signGroup);
                sceneryObjects.push(signGroup);
            }

            // --- Engel ve Coin Oluşturma Fonksiyonları ---
            function createObstacle(lane, zPosition) {
                let obstacleMesh;
                const type = Math.random();
                if (type < 0.4) { // Kırılabilir Kutular
                    const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
                    const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });
                    obstacleMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                    obstacleMesh.position.set(lane * LANE_WIDTH, 0.5, zPosition);
                    obstacleMesh.isBreakable = true;

                    // "KUTU" yazısı
                    if (loadedFont) {
                        try {
                            const textGeometry = new TextGeometry( 'KUTU', {
                                font: loadedFont,
                                size: 0.4,
                                height: 0.1,
                                curveSegments: 2,
                                bevelEnabled: false
                            });
                            const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                            textGeometry.computeBoundingBox();
                            const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                            const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
                            textMesh.position.set(-textWidth / 2, 0.5 - textHeight / 2, 0.51);
                            obstacleMesh.add(textMesh);
                        } catch (e) {
                            console.error("Kutu yazısı objesi oluşturulurken hata:", e);
                        }
                    }


                } else if (type < 0.7) { // Zıplanabilir Duvar
                    const wallGeometry = new THREE.BoxGeometry(2, 1.2, 0.5);
                    const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                    obstacleMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                    obstacleMesh.position.set(lane * LANE_WIDTH, 0.6, zPosition);
                    obstacleMesh.isJumpable = true;
                } else { // Yüksek Engel
                    const tallObstacleGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.8);
                    const tallObstacleMaterial = new THREE.MeshLambertMaterial({ color: 0xA0522D });
                    obstacleMesh = new THREE.Mesh(tallObstacleGeometry, tallObstacleMaterial);
                    obstacleMesh.position.set(lane * LANE_WIDTH, 1.25, zPosition);
                    obstacleMesh.isJumpable = false;
                }
                scene.add(obstacleMesh);
                obstacles.push(obstacleMesh);
            }

            function createCoin(lane, zPosition) {
                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                coin.rotation.x = Math.PI / 2;
                coin.position.set(lane * LANE_WIDTH, 0.5, zPosition);
                scene.add(coin);
                coinsArray.push(coin);
            }

            // --- Çarpışma Tespiti ---
            function checkCollision(obj1, obj2) {
                const box1 = new THREE.Box3().setFromObject(obj1);
                const box2 = new THREE.Box3().setFromObject(obj2);
                return box1.intersectsBox(box2);
            }

            // --- Klavye Kontrolleri ---
            const keys = {};
            document.addEventListener('keydown', (event) => {
                if (isGamePaused) {
                    return;
                }
                keys[event.key.toLowerCase()] = true;
            });
            document.addEventListener('keyup', (event) => {
                keys[event.key.toLowerCase()] = false;
            });

            // --- Dokunmatik Kontroller (Telefon İçin) ---
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (event) => {
                if (isGamePaused) {
                    return;
                }
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }, false);

            document.addEventListener('touchend', (event) => {
                if (isGamePaused) {
                    return;
                }
                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;

                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                // Dikey kaydırma (zıplama)
                if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 50) {
                    if (dy < 0 && !isJumping) {
                        isJumping = true;
                        jumpVelocity = jumpForce;
                    }
                }
                // Yatay kaydırma (şerit değiştirme)
                else if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) {
                    if (dx > 0) { // Sağa kaydırma
                        currentLane = Math.min(currentLane + 1, 1);
                        playerRotationTarget = -Math.PI / 10;
                    } else { // Sola kaydırma
                        currentLane = Math.max(currentLane - 1, -1);
                        playerRotationTarget = Math.PI / 10;
                    }
                }
            }, false);

            // --- Animasyon Döngüsü ---
            let lastFrameTime = performance.now();

            function animate() {
                requestAnimationFrame(animate);

                const currentTime = performance.now();
                const deltaTime = (currentTime - lastFrameTime) / 1000;
                lastFrameTime = currentTime;

                if (isGamePaused) {
                    renderer.render(scene, camera);
                    return;
                }

                // Hızlandırma gücü sayacı
                if (isSpeedBoostActive) {
                    speedBoostTimer -= deltaTime;
                    if (speedBoostTimer <= 0) {
                        isSpeedBoostActive = false;
                        playerSpeed = 0.1;
                        console.log("Hızlandırma sona erdi.");
                    }
                }

                // Skor Güncelleme
                score += deltaTime * (isSpeedBoostActive ? SPEED_BOOST_MULTIPLIER : 1);
                updateScoreAndCoinsDisplay();

                // Oyuncuyu sürekli ileri hareket ettir
                player.position.z -= playerSpeed;
                camera.position.z = player.position.z + 5;

                // Oyuncunun şerit pozisyonunu güncelle ve dönüş animasyonu
                const targetX = currentLane * LANE_WIDTH;
                player.position.x += (targetX - player.position.x) * 0.1;
                player.rotation.y += (playerRotationTarget - player.rotation.y) * 0.2;


                // Zıplama Mantığı
                if (isJumping) {
                    player.position.y += jumpVelocity;
                    jumpVelocity += gravity;

                    if (playerLeftFoot && playerRightFoot) {
                        if (playerLeftFoot.visible) {
                            playerLeftFoot.visible = false;
                            playerRightFoot.visible = false;
                        }
                    }

                    if (playerLeftArm && playerRightArm) {
                        const jumpHeightRatio = (player.position.y - 0.9) / (jumpForce * jumpForce / (2 * Math.abs(gravity)));
                        playerLeftArm.rotation.x = -Math.PI / 2 * Math.min(1, jumpHeightRatio * 2);
                        playerRightArm.rotation.x = -Math.PI / 2 * Math.min(1, jumpHeightRatio * 2);
                    }


                    if (player.position.y <= 0.9) {
                        player.position.y = 0.9;
                        isJumping = false;
                        jumpVelocity = 0;

                        if (playerBody && playerLeftFoot && playerRightFoot && playerLeftArm && playerRightArm) {
                            playerBody.scale.y = 1;
                            playerBody.position.y = 0;
                            playerLeftFoot.rotation.x = 0;
                            playerRightFoot.rotation.x = 0;
                            playerLeftFoot.position.y = -1.2;
                            playerRightFoot.position.y = -1.2;
                            playerLeftFoot.position.z = 0;
                            playerRightFoot.position.z = 0;
                            playerLeftArm.rotation.x = 0;
                            playerRightArm.rotation.x = 0;
                            playerRotationTarget = 0;
                            playerLeftFoot.visible = true;
                            playerRightFoot.visible = true;
                        } else {
                            console.warn("Player body parts missing on jump land, cannot reset animation.");
                        }
                    }
                } else {
                    // Koşu Animasyonu (Yerdeyse)
                    animationTime += runAnimationSpeed;
                    if (playerBody && playerLeftFoot && playerRightFoot && playerLeftArm && playerRightArm) {
                        playerBody.position.y = Math.sin(animationTime * 2) * 0.05;

                        playerLeftFoot.position.z = Math.sin(animationTime) * 0.2;
                        playerLeftFoot.position.y = -1.2 + Math.abs(Math.sin(animationTime)) * 0.2;

                        playerRightFoot.position.z = Math.sin(animationTime + Math.PI) * 0.2;
                        playerRightFoot.position.y = -1.2 + Math.abs(Math.sin(animationTime + Math.PI)) * 0.2;

                        playerLeftArm.rotation.x = Math.sin(animationTime + Math.PI) * 0.4;
                        playerRightArm.rotation.x = Math.sin(animationTime) * 0.4;
                    } else {
                        console.warn("Player body parts missing during run animation.");
                    }
                }

                // Klavye ile zıplama
                if (keys[' '] && !isJumping) {
                    isJumping = true;
                    jumpVelocity = jumpForce;
                }

                // Klavye ile yana kayma (A/D veya Sol/Sağ Ok)
                if (keys['a'] || keys['arrowleft']) {
                    currentLane = Math.max(currentLane - 1, -1);
                    playerRotationTarget = Math.PI / 10;
                    keys['a'] = false;
                    keys['arrowleft'] = false;
                }
                if (keys['d'] || keys['arrowright']) {
                    currentLane = Math.min(currentLane + 1, 1);
                    playerRotationTarget = -Math.PI / 10;
                    keys['d'] = false;
                    keys['arrowright'] = false;
                }
                if (!keys['a'] && !keys['d'] && !keys['arrowleft'] && !keys['arrowright'] && !isJumping) {
                    playerRotationTarget = 0;
                }


                // --- Engel, Coin, Kırılabilir Kutu ve Mahalle Objeleri Üretimi ---
                if (player.position.z - lastSpawnZ < -Math.random() * (spawnDistanceMax - spawnDistanceMin) - spawnDistanceMin) {
                    const randomLane = Math.floor(Math.random() * 3) - 1;
                    const spawnChoice = Math.random();
                    const spawnZ = player.position.z - (Math.random() * 50 + 30);

                    if (spawnChoice < 0.6) {
                        createObstacle(randomLane, spawnZ);
                    } else {
                        createCoin(randomLane, spawnZ);
                    }
                    lastSpawnZ = player.position.z;
                }

                // Mahalle objelerini üretme
                if (player.position.z - lastScenerySpawnZ < -scenerySpawnDistance) {
                    const zPos = player.position.z - (Math.random() * 50 + 100);
                    const side = Math.random() < 0.5 ? -1 : 1;

                    const spawnX = side * roadSideOffset + (side * (Math.random() * 5));

                    const objectTypeChoice = Math.random();
                    if (objectTypeChoice < 0.3) {
                        const buildingWidth = Math.random() * 10 + 5;
                        const buildingHeight = Math.random() * 15 + 10;
                        const buildingDepth = Math.random() * 8 + 5;
                        const buildingColor = new THREE.Color(Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3);
                        createBuilding(spawnX, zPos, buildingWidth, buildingHeight, buildingDepth, buildingColor);
                    } else if (objectTypeChoice < 0.6) {
                        createTree(spawnX, zPos + Math.random() * 10 - 5);
                    } else if (objectTypeChoice < 0.8) {
                        createRoadSign(spawnX, zPos + Math.random() * 10 - 5);
                    } else {
                        createFence(spawnX, zPos + Math.random() * 10 - 5, 5, 1);
                    }

                    lastScenerySpawnZ = player.position.z;
                }


                // --- Objeleri Hareket Ettirme ve Silme ---
                const cleanupDistance = camera.position.z + 20;

                // Engeller
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.position.z += playerSpeed;

                    if (checkCollision(player, obstacle)) {
                        if (obstacle.isBreakable) {
                            const earnedCoins = Math.floor(Math.random() * 5) + 1;
                            playerCoins += earnedCoins;
                            updateScoreAndCoinsDisplay();
                            scene.remove(obstacle);
                            obstacles.splice(i, 1);
                        } else if (obstacle.isJumpable && isJumping && player.position.y > obstacle.position.y + obstacle.geometry.parameters.height / 2 - 0.2) {
                            // Üzerinden atladı
                        }
                        else {
                            console.log("Çarpıştın! Oyun Bitti!");
                            isGamePaused = true;
                            shopButton.textContent = "Tekrar Oyna";
                            shopButton.onclick = () => {
                                location.reload();
                            };
                            uiContainer.classList.add('disabled-for-game');
                            return;
                        }
                    }

                    if (obstacle.position.z > cleanupDistance) {
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                    }
                }

                // Coinler
                for (let i = coinsArray.length - 1; i >= 0; i--) {
                    const coin = coinsArray[i];
                    coin.position.z += playerSpeed;
                    coin.rotation.y += 0.05;

                    if (checkCollision(player, coin) && coin.visible) {
                        playerCoins += 1;
                        updateScoreAndCoinsDisplay();
                        scene.remove(coin);
                        coin.visible = false;
                    }

                    if (coin.position.z > cleanupDistance) {
                        scene.remove(coin);
                        coinsArray.splice(i, 1);
                    }
                }

                // Mahalle objeleri
                for (let i = sceneryObjects.length - 1; i >= 0; i--) {
                    const obj = sceneryObjects[i];
                    obj.position.z += playerSpeed;

                    if (obj.position.z > cleanupDistance) {
                        scene.remove(obj);
                        sceneryObjects.splice(i, 1);
                    }
                }

                renderer.render(scene, camera);
            }

            // Başlangıçta dükkanı doldur ve hızlandırma butonunu güncelle
            // Bu çağrılar, DOM elementleri ve Three.js sahnesi hazır olduktan sonra yapılmalıdır.
            populateShop();
            updateSpeedBoostButton();

            // Animasyon döngüsünü başlat
            animate();

            // --- Pencere Boyutu Değiştiğinde Yeniden Boyutlandırma ---
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            console.log("Oyun başlatma sırası tamamlandı.");
        }); // DOMContentLoaded sonu
    </script>
</body>
</html>
